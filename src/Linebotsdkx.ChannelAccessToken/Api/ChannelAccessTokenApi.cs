/*
 * Channel Access Token API
 *
 * This document describes Channel Access Token API.
 *
 * The version of the OpenAPI document: 0.0.1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Linebotsdkx.ChannelAccessToken.Client;
using Linebotsdkx.ChannelAccessToken.Model;

namespace Linebotsdkx.ChannelAccessToken.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IChannelAccessTokenApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets all valid channel access token key IDs.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientAssertionType">&#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60;</param>
        /// <param name="clientAssertion">A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ChannelAccessTokenKeyIdsResponse</returns>
        ChannelAccessTokenKeyIdsResponse GetsAllValidChannelAccessTokenKeyIds(string clientAssertionType, string clientAssertion, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets all valid channel access token key IDs.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientAssertionType">&#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60;</param>
        /// <param name="clientAssertion">A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ChannelAccessTokenKeyIdsResponse</returns>
        ApiResponse<ChannelAccessTokenKeyIdsResponse> GetsAllValidChannelAccessTokenKeyIdsWithHttpInfo(string clientAssertionType, string clientAssertion, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issue short-lived channel access token
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60;</param>
        /// <param name="clientId">Channel ID.</param>
        /// <param name="clientSecret">Channel secret.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueShortLivedChannelAccessTokenResponse</returns>
        IssueShortLivedChannelAccessTokenResponse IssueChannelToken(string grantType, string clientId, string clientSecret, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issue short-lived channel access token
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60;</param>
        /// <param name="clientId">Channel ID.</param>
        /// <param name="clientSecret">Channel secret.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueShortLivedChannelAccessTokenResponse</returns>
        ApiResponse<IssueShortLivedChannelAccessTokenResponse> IssueChannelTokenWithHttpInfo(string grantType, string clientId, string clientSecret, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">client_credentials</param>
        /// <param name="clientAssertionType">urn:ietf:params:oauth:client-assertion-type:jwt-bearer</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueChannelAccessTokenResponse</returns>
        IssueChannelAccessTokenResponse IssueChannelTokenByJWT(string grantType, string clientAssertionType, string clientAssertion, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">client_credentials</param>
        /// <param name="clientAssertionType">urn:ietf:params:oauth:client-assertion-type:jwt-bearer</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueChannelAccessTokenResponse</returns>
        ApiResponse<IssueChannelAccessTokenResponse> IssueChannelTokenByJWTWithHttpInfo(string grantType, string clientAssertionType, string clientAssertion, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issues a new stateless channel access token, which doesn&#39;t have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60; (optional)</param>
        /// <param name="clientAssertionType">URL-encoded value of &#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60; (optional)</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key. (optional)</param>
        /// <param name="clientId">Channel ID. (optional)</param>
        /// <param name="clientSecret">Channel secret. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueStatelessChannelAccessTokenResponse</returns>
        IssueStatelessChannelAccessTokenResponse IssueStatelessChannelToken(string? grantType = default(string?), string? clientAssertionType = default(string?), string? clientAssertion = default(string?), string? clientId = default(string?), string? clientSecret = default(string?), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issues a new stateless channel access token, which doesn&#39;t have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60; (optional)</param>
        /// <param name="clientAssertionType">URL-encoded value of &#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60; (optional)</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key. (optional)</param>
        /// <param name="clientId">Channel ID. (optional)</param>
        /// <param name="clientSecret">Channel secret. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueStatelessChannelAccessTokenResponse</returns>
        ApiResponse<IssueStatelessChannelAccessTokenResponse> IssueStatelessChannelTokenWithHttpInfo(string? grantType = default(string?), string? clientAssertionType = default(string?), string? clientAssertion = default(string?), string? clientId = default(string?), string? clientSecret = default(string?), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Revoke short-lived or long-lived channel access token
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RevokeChannelToken(string accessToken, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Revoke short-lived or long-lived channel access token
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RevokeChannelTokenWithHttpInfo(string accessToken, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Revoke channel access token v2.1
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Channel ID</param>
        /// <param name="clientSecret">Channel Secret</param>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void RevokeChannelTokenByJWT(string clientId, string clientSecret, string accessToken, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Revoke channel access token v2.1
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Channel ID</param>
        /// <param name="clientSecret">Channel Secret</param>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RevokeChannelTokenByJWTWithHttpInfo(string clientId, string clientSecret, string accessToken, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Verify the validity of short-lived and long-lived channel access tokens
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">A short-lived or long-lived channel access token.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>VerifyChannelAccessTokenResponse</returns>
        VerifyChannelAccessTokenResponse VerifyChannelToken(string accessToken, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Verify the validity of short-lived and long-lived channel access tokens
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">A short-lived or long-lived channel access token.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of VerifyChannelAccessTokenResponse</returns>
        ApiResponse<VerifyChannelAccessTokenResponse> VerifyChannelTokenWithHttpInfo(string accessToken, int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token with a user-specified expiration (Channel Access Token v2.1).</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>VerifyChannelAccessTokenResponse</returns>
        VerifyChannelAccessTokenResponse VerifyChannelTokenByJWT(string accessToken, int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token with a user-specified expiration (Channel Access Token v2.1).</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of VerifyChannelAccessTokenResponse</returns>
        ApiResponse<VerifyChannelAccessTokenResponse> VerifyChannelTokenByJWTWithHttpInfo(string accessToken, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IChannelAccessTokenApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets all valid channel access token key IDs.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientAssertionType">&#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60;</param>
        /// <param name="clientAssertion">A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ChannelAccessTokenKeyIdsResponse</returns>
        System.Threading.Tasks.Task<ChannelAccessTokenKeyIdsResponse> GetsAllValidChannelAccessTokenKeyIdsAsync(string clientAssertionType, string clientAssertion, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Gets all valid channel access token key IDs.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientAssertionType">&#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60;</param>
        /// <param name="clientAssertion">A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ChannelAccessTokenKeyIdsResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ChannelAccessTokenKeyIdsResponse>> GetsAllValidChannelAccessTokenKeyIdsWithHttpInfoAsync(string clientAssertionType, string clientAssertion, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issue short-lived channel access token
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60;</param>
        /// <param name="clientId">Channel ID.</param>
        /// <param name="clientSecret">Channel secret.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueShortLivedChannelAccessTokenResponse</returns>
        System.Threading.Tasks.Task<IssueShortLivedChannelAccessTokenResponse> IssueChannelTokenAsync(string grantType, string clientId, string clientSecret, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issue short-lived channel access token
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60;</param>
        /// <param name="clientId">Channel ID.</param>
        /// <param name="clientSecret">Channel secret.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueShortLivedChannelAccessTokenResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueShortLivedChannelAccessTokenResponse>> IssueChannelTokenWithHttpInfoAsync(string grantType, string clientId, string clientSecret, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">client_credentials</param>
        /// <param name="clientAssertionType">urn:ietf:params:oauth:client-assertion-type:jwt-bearer</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueChannelAccessTokenResponse</returns>
        System.Threading.Tasks.Task<IssueChannelAccessTokenResponse> IssueChannelTokenByJWTAsync(string grantType, string clientAssertionType, string clientAssertion, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">client_credentials</param>
        /// <param name="clientAssertionType">urn:ietf:params:oauth:client-assertion-type:jwt-bearer</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueChannelAccessTokenResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueChannelAccessTokenResponse>> IssueChannelTokenByJWTWithHttpInfoAsync(string grantType, string clientAssertionType, string clientAssertion, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issues a new stateless channel access token, which doesn&#39;t have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60; (optional)</param>
        /// <param name="clientAssertionType">URL-encoded value of &#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60; (optional)</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key. (optional)</param>
        /// <param name="clientId">Channel ID. (optional)</param>
        /// <param name="clientSecret">Channel secret. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueStatelessChannelAccessTokenResponse</returns>
        System.Threading.Tasks.Task<IssueStatelessChannelAccessTokenResponse> IssueStatelessChannelTokenAsync(string? grantType = default(string?), string? clientAssertionType = default(string?), string? clientAssertion = default(string?), string? clientId = default(string?), string? clientSecret = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Issues a new stateless channel access token, which doesn&#39;t have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60; (optional)</param>
        /// <param name="clientAssertionType">URL-encoded value of &#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60; (optional)</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key. (optional)</param>
        /// <param name="clientId">Channel ID. (optional)</param>
        /// <param name="clientSecret">Channel secret. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueStatelessChannelAccessTokenResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueStatelessChannelAccessTokenResponse>> IssueStatelessChannelTokenWithHttpInfoAsync(string? grantType = default(string?), string? clientAssertionType = default(string?), string? clientAssertion = default(string?), string? clientId = default(string?), string? clientSecret = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Revoke short-lived or long-lived channel access token
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RevokeChannelTokenAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Revoke short-lived or long-lived channel access token
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RevokeChannelTokenWithHttpInfoAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Revoke channel access token v2.1
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Channel ID</param>
        /// <param name="clientSecret">Channel Secret</param>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RevokeChannelTokenByJWTAsync(string clientId, string clientSecret, string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Revoke channel access token v2.1
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Channel ID</param>
        /// <param name="clientSecret">Channel Secret</param>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RevokeChannelTokenByJWTWithHttpInfoAsync(string clientId, string clientSecret, string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Verify the validity of short-lived and long-lived channel access tokens
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">A short-lived or long-lived channel access token.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VerifyChannelAccessTokenResponse</returns>
        System.Threading.Tasks.Task<VerifyChannelAccessTokenResponse> VerifyChannelTokenAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Verify the validity of short-lived and long-lived channel access tokens
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">A short-lived or long-lived channel access token.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VerifyChannelAccessTokenResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<VerifyChannelAccessTokenResponse>> VerifyChannelTokenWithHttpInfoAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token with a user-specified expiration (Channel Access Token v2.1).</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VerifyChannelAccessTokenResponse</returns>
        System.Threading.Tasks.Task<VerifyChannelAccessTokenResponse> VerifyChannelTokenByJWTAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
        /// </remarks>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token with a user-specified expiration (Channel Access Token v2.1).</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VerifyChannelAccessTokenResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<VerifyChannelAccessTokenResponse>> VerifyChannelTokenByJWTWithHttpInfoAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IChannelAccessTokenApi : IChannelAccessTokenApiSync, IChannelAccessTokenApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ChannelAccessTokenApi : IChannelAccessTokenApi
    {
        private Linebotsdkx.ChannelAccessToken.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelAccessTokenApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ChannelAccessTokenApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelAccessTokenApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ChannelAccessTokenApi(string basePath)
        {
            this.Configuration = Linebotsdkx.ChannelAccessToken.Client.Configuration.MergeConfigurations(
                Linebotsdkx.ChannelAccessToken.Client.GlobalConfiguration.Instance,
                new Linebotsdkx.ChannelAccessToken.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Linebotsdkx.ChannelAccessToken.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Linebotsdkx.ChannelAccessToken.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Linebotsdkx.ChannelAccessToken.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelAccessTokenApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ChannelAccessTokenApi(Linebotsdkx.ChannelAccessToken.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Linebotsdkx.ChannelAccessToken.Client.Configuration.MergeConfigurations(
                Linebotsdkx.ChannelAccessToken.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Linebotsdkx.ChannelAccessToken.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Linebotsdkx.ChannelAccessToken.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Linebotsdkx.ChannelAccessToken.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChannelAccessTokenApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ChannelAccessTokenApi(Linebotsdkx.ChannelAccessToken.Client.ISynchronousClient client, Linebotsdkx.ChannelAccessToken.Client.IAsynchronousClient asyncClient, Linebotsdkx.ChannelAccessToken.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Linebotsdkx.ChannelAccessToken.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Linebotsdkx.ChannelAccessToken.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Linebotsdkx.ChannelAccessToken.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Linebotsdkx.ChannelAccessToken.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Linebotsdkx.ChannelAccessToken.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Gets all valid channel access token key IDs.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientAssertionType">&#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60;</param>
        /// <param name="clientAssertion">A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ChannelAccessTokenKeyIdsResponse</returns>
        public ChannelAccessTokenKeyIdsResponse GetsAllValidChannelAccessTokenKeyIds(string clientAssertionType, string clientAssertion, int operationIndex = 0)
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<ChannelAccessTokenKeyIdsResponse> localVarResponse = GetsAllValidChannelAccessTokenKeyIdsWithHttpInfo(clientAssertionType, clientAssertion);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Gets all valid channel access token key IDs.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientAssertionType">&#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60;</param>
        /// <param name="clientAssertion">A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ChannelAccessTokenKeyIdsResponse</returns>
        public Linebotsdkx.ChannelAccessToken.Client.ApiResponse<ChannelAccessTokenKeyIdsResponse> GetsAllValidChannelAccessTokenKeyIdsWithHttpInfo(string clientAssertionType, string clientAssertion, int operationIndex = 0)
        {
            // verify the required parameter 'clientAssertionType' is set
            if (clientAssertionType == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientAssertionType' when calling ChannelAccessTokenApi->GetsAllValidChannelAccessTokenKeyIds");
            }

            // verify the required parameter 'clientAssertion' is set
            if (clientAssertion == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientAssertion' when calling ChannelAccessTokenApi->GetsAllValidChannelAccessTokenKeyIds");
            }

            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToMultiMap("", "client_assertion_type", clientAssertionType));
            localVarRequestOptions.QueryParameters.Add(Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToMultiMap("", "client_assertion", clientAssertion));

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.GetsAllValidChannelAccessTokenKeyIds";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<ChannelAccessTokenKeyIdsResponse>("/oauth2/v2.1/tokens/kid", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetsAllValidChannelAccessTokenKeyIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Gets all valid channel access token key IDs.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientAssertionType">&#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60;</param>
        /// <param name="clientAssertion">A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ChannelAccessTokenKeyIdsResponse</returns>
        public async System.Threading.Tasks.Task<ChannelAccessTokenKeyIdsResponse> GetsAllValidChannelAccessTokenKeyIdsAsync(string clientAssertionType, string clientAssertion, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<ChannelAccessTokenKeyIdsResponse> localVarResponse = await GetsAllValidChannelAccessTokenKeyIdsWithHttpInfoAsync(clientAssertionType, clientAssertion, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Gets all valid channel access token key IDs.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientAssertionType">&#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60;</param>
        /// <param name="clientAssertion">A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ChannelAccessTokenKeyIdsResponse)</returns>
        public async System.Threading.Tasks.Task<Linebotsdkx.ChannelAccessToken.Client.ApiResponse<ChannelAccessTokenKeyIdsResponse>> GetsAllValidChannelAccessTokenKeyIdsWithHttpInfoAsync(string clientAssertionType, string clientAssertion, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'clientAssertionType' is set
            if (clientAssertionType == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientAssertionType' when calling ChannelAccessTokenApi->GetsAllValidChannelAccessTokenKeyIds");
            }

            // verify the required parameter 'clientAssertion' is set
            if (clientAssertion == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientAssertion' when calling ChannelAccessTokenApi->GetsAllValidChannelAccessTokenKeyIds");
            }


            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToMultiMap("", "client_assertion_type", clientAssertionType));
            localVarRequestOptions.QueryParameters.Add(Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToMultiMap("", "client_assertion", clientAssertion));

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.GetsAllValidChannelAccessTokenKeyIds";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<ChannelAccessTokenKeyIdsResponse>("/oauth2/v2.1/tokens/kid", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetsAllValidChannelAccessTokenKeyIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Issue short-lived channel access token
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60;</param>
        /// <param name="clientId">Channel ID.</param>
        /// <param name="clientSecret">Channel secret.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueShortLivedChannelAccessTokenResponse</returns>
        public IssueShortLivedChannelAccessTokenResponse IssueChannelToken(string grantType, string clientId, string clientSecret, int operationIndex = 0)
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueShortLivedChannelAccessTokenResponse> localVarResponse = IssueChannelTokenWithHttpInfo(grantType, clientId, clientSecret);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Issue short-lived channel access token
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60;</param>
        /// <param name="clientId">Channel ID.</param>
        /// <param name="clientSecret">Channel secret.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueShortLivedChannelAccessTokenResponse</returns>
        public Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueShortLivedChannelAccessTokenResponse> IssueChannelTokenWithHttpInfo(string grantType, string clientId, string clientSecret, int operationIndex = 0)
        {
            // verify the required parameter 'grantType' is set
            if (grantType == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'grantType' when calling ChannelAccessTokenApi->IssueChannelToken");
            }

            // verify the required parameter 'clientId' is set
            if (clientId == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientId' when calling ChannelAccessTokenApi->IssueChannelToken");
            }

            // verify the required parameter 'clientSecret' is set
            if (clientSecret == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientSecret' when calling ChannelAccessTokenApi->IssueChannelToken");
            }

            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("grant_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(grantType)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_id", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientId)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_secret", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientSecret)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.IssueChannelToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<IssueShortLivedChannelAccessTokenResponse>("/v2/oauth/accessToken", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IssueChannelToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Issue short-lived channel access token
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60;</param>
        /// <param name="clientId">Channel ID.</param>
        /// <param name="clientSecret">Channel secret.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueShortLivedChannelAccessTokenResponse</returns>
        public async System.Threading.Tasks.Task<IssueShortLivedChannelAccessTokenResponse> IssueChannelTokenAsync(string grantType, string clientId, string clientSecret, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueShortLivedChannelAccessTokenResponse> localVarResponse = await IssueChannelTokenWithHttpInfoAsync(grantType, clientId, clientSecret, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Issue short-lived channel access token
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60;</param>
        /// <param name="clientId">Channel ID.</param>
        /// <param name="clientSecret">Channel secret.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueShortLivedChannelAccessTokenResponse)</returns>
        public async System.Threading.Tasks.Task<Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueShortLivedChannelAccessTokenResponse>> IssueChannelTokenWithHttpInfoAsync(string grantType, string clientId, string clientSecret, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'grantType' is set
            if (grantType == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'grantType' when calling ChannelAccessTokenApi->IssueChannelToken");
            }

            // verify the required parameter 'clientId' is set
            if (clientId == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientId' when calling ChannelAccessTokenApi->IssueChannelToken");
            }

            // verify the required parameter 'clientSecret' is set
            if (clientSecret == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientSecret' when calling ChannelAccessTokenApi->IssueChannelToken");
            }


            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("grant_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(grantType)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_id", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientId)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_secret", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientSecret)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.IssueChannelToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<IssueShortLivedChannelAccessTokenResponse>("/v2/oauth/accessToken", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IssueChannelToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">client_credentials</param>
        /// <param name="clientAssertionType">urn:ietf:params:oauth:client-assertion-type:jwt-bearer</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueChannelAccessTokenResponse</returns>
        public IssueChannelAccessTokenResponse IssueChannelTokenByJWT(string grantType, string clientAssertionType, string clientAssertion, int operationIndex = 0)
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueChannelAccessTokenResponse> localVarResponse = IssueChannelTokenByJWTWithHttpInfo(grantType, clientAssertionType, clientAssertion);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">client_credentials</param>
        /// <param name="clientAssertionType">urn:ietf:params:oauth:client-assertion-type:jwt-bearer</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueChannelAccessTokenResponse</returns>
        public Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueChannelAccessTokenResponse> IssueChannelTokenByJWTWithHttpInfo(string grantType, string clientAssertionType, string clientAssertion, int operationIndex = 0)
        {
            // verify the required parameter 'grantType' is set
            if (grantType == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'grantType' when calling ChannelAccessTokenApi->IssueChannelTokenByJWT");
            }

            // verify the required parameter 'clientAssertionType' is set
            if (clientAssertionType == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientAssertionType' when calling ChannelAccessTokenApi->IssueChannelTokenByJWT");
            }

            // verify the required parameter 'clientAssertion' is set
            if (clientAssertion == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientAssertion' when calling ChannelAccessTokenApi->IssueChannelTokenByJWT");
            }

            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("grant_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(grantType)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_assertion_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientAssertionType)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_assertion", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientAssertion)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.IssueChannelTokenByJWT";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<IssueChannelAccessTokenResponse>("/oauth2/v2.1/token", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IssueChannelTokenByJWT", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">client_credentials</param>
        /// <param name="clientAssertionType">urn:ietf:params:oauth:client-assertion-type:jwt-bearer</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueChannelAccessTokenResponse</returns>
        public async System.Threading.Tasks.Task<IssueChannelAccessTokenResponse> IssueChannelTokenByJWTAsync(string grantType, string clientAssertionType, string clientAssertion, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueChannelAccessTokenResponse> localVarResponse = await IssueChannelTokenByJWTWithHttpInfoAsync(grantType, clientAssertionType, clientAssertion, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">client_credentials</param>
        /// <param name="clientAssertionType">urn:ietf:params:oauth:client-assertion-type:jwt-bearer</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueChannelAccessTokenResponse)</returns>
        public async System.Threading.Tasks.Task<Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueChannelAccessTokenResponse>> IssueChannelTokenByJWTWithHttpInfoAsync(string grantType, string clientAssertionType, string clientAssertion, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'grantType' is set
            if (grantType == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'grantType' when calling ChannelAccessTokenApi->IssueChannelTokenByJWT");
            }

            // verify the required parameter 'clientAssertionType' is set
            if (clientAssertionType == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientAssertionType' when calling ChannelAccessTokenApi->IssueChannelTokenByJWT");
            }

            // verify the required parameter 'clientAssertion' is set
            if (clientAssertion == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientAssertion' when calling ChannelAccessTokenApi->IssueChannelTokenByJWT");
            }


            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("grant_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(grantType)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_assertion_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientAssertionType)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_assertion", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientAssertion)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.IssueChannelTokenByJWT";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<IssueChannelAccessTokenResponse>("/oauth2/v2.1/token", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IssueChannelTokenByJWT", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Issues a new stateless channel access token, which doesn&#39;t have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60; (optional)</param>
        /// <param name="clientAssertionType">URL-encoded value of &#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60; (optional)</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key. (optional)</param>
        /// <param name="clientId">Channel ID. (optional)</param>
        /// <param name="clientSecret">Channel secret. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueStatelessChannelAccessTokenResponse</returns>
        public IssueStatelessChannelAccessTokenResponse IssueStatelessChannelToken(string? grantType = default(string?), string? clientAssertionType = default(string?), string? clientAssertion = default(string?), string? clientId = default(string?), string? clientSecret = default(string?), int operationIndex = 0)
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueStatelessChannelAccessTokenResponse> localVarResponse = IssueStatelessChannelTokenWithHttpInfo(grantType, clientAssertionType, clientAssertion, clientId, clientSecret);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Issues a new stateless channel access token, which doesn&#39;t have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60; (optional)</param>
        /// <param name="clientAssertionType">URL-encoded value of &#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60; (optional)</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key. (optional)</param>
        /// <param name="clientId">Channel ID. (optional)</param>
        /// <param name="clientSecret">Channel secret. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueStatelessChannelAccessTokenResponse</returns>
        public Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueStatelessChannelAccessTokenResponse> IssueStatelessChannelTokenWithHttpInfo(string? grantType = default(string?), string? clientAssertionType = default(string?), string? clientAssertion = default(string?), string? clientId = default(string?), string? clientSecret = default(string?), int operationIndex = 0)
        {
            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (grantType != null)
            {
                localVarRequestOptions.FormParameters.Add("grant_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(grantType)); // form parameter
            }
            if (clientAssertionType != null)
            {
                localVarRequestOptions.FormParameters.Add("client_assertion_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientAssertionType)); // form parameter
            }
            if (clientAssertion != null)
            {
                localVarRequestOptions.FormParameters.Add("client_assertion", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientAssertion)); // form parameter
            }
            if (clientId != null)
            {
                localVarRequestOptions.FormParameters.Add("client_id", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientId)); // form parameter
            }
            if (clientSecret != null)
            {
                localVarRequestOptions.FormParameters.Add("client_secret", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientSecret)); // form parameter
            }

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.IssueStatelessChannelToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<IssueStatelessChannelAccessTokenResponse>("/oauth2/v3/token", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IssueStatelessChannelToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Issues a new stateless channel access token, which doesn&#39;t have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60; (optional)</param>
        /// <param name="clientAssertionType">URL-encoded value of &#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60; (optional)</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key. (optional)</param>
        /// <param name="clientId">Channel ID. (optional)</param>
        /// <param name="clientSecret">Channel secret. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueStatelessChannelAccessTokenResponse</returns>
        public async System.Threading.Tasks.Task<IssueStatelessChannelAccessTokenResponse> IssueStatelessChannelTokenAsync(string? grantType = default(string?), string? clientAssertionType = default(string?), string? clientAssertion = default(string?), string? clientId = default(string?), string? clientSecret = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueStatelessChannelAccessTokenResponse> localVarResponse = await IssueStatelessChannelTokenWithHttpInfoAsync(grantType, clientAssertionType, clientAssertion, clientId, clientSecret, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Issues a new stateless channel access token, which doesn&#39;t have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="grantType">&#x60;client_credentials&#x60; (optional)</param>
        /// <param name="clientAssertionType">URL-encoded value of &#x60;urn:ietf:params:oauth:client-assertion-type:jwt-bearer&#x60; (optional)</param>
        /// <param name="clientAssertion">A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key. (optional)</param>
        /// <param name="clientId">Channel ID. (optional)</param>
        /// <param name="clientSecret">Channel secret. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueStatelessChannelAccessTokenResponse)</returns>
        public async System.Threading.Tasks.Task<Linebotsdkx.ChannelAccessToken.Client.ApiResponse<IssueStatelessChannelAccessTokenResponse>> IssueStatelessChannelTokenWithHttpInfoAsync(string? grantType = default(string?), string? clientAssertionType = default(string?), string? clientAssertion = default(string?), string? clientId = default(string?), string? clientSecret = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (grantType != null)
            {
                localVarRequestOptions.FormParameters.Add("grant_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(grantType)); // form parameter
            }
            if (clientAssertionType != null)
            {
                localVarRequestOptions.FormParameters.Add("client_assertion_type", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientAssertionType)); // form parameter
            }
            if (clientAssertion != null)
            {
                localVarRequestOptions.FormParameters.Add("client_assertion", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientAssertion)); // form parameter
            }
            if (clientId != null)
            {
                localVarRequestOptions.FormParameters.Add("client_id", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientId)); // form parameter
            }
            if (clientSecret != null)
            {
                localVarRequestOptions.FormParameters.Add("client_secret", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientSecret)); // form parameter
            }

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.IssueStatelessChannelToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<IssueStatelessChannelAccessTokenResponse>("/oauth2/v3/token", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IssueStatelessChannelToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Revoke short-lived or long-lived channel access token
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RevokeChannelToken(string accessToken, int operationIndex = 0)
        {
            RevokeChannelTokenWithHttpInfo(accessToken);
        }

        /// <summary>
        ///  Revoke short-lived or long-lived channel access token
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Linebotsdkx.ChannelAccessToken.Client.ApiResponse<Object> RevokeChannelTokenWithHttpInfo(string accessToken, int operationIndex = 0)
        {
            // verify the required parameter 'accessToken' is set
            if (accessToken == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'accessToken' when calling ChannelAccessTokenApi->RevokeChannelToken");
            }

            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("access_token", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(accessToken)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.RevokeChannelToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/v2/oauth/revoke", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RevokeChannelToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Revoke short-lived or long-lived channel access token
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RevokeChannelTokenAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RevokeChannelTokenWithHttpInfoAsync(accessToken, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Revoke short-lived or long-lived channel access token
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Linebotsdkx.ChannelAccessToken.Client.ApiResponse<Object>> RevokeChannelTokenWithHttpInfoAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'accessToken' is set
            if (accessToken == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'accessToken' when calling ChannelAccessTokenApi->RevokeChannelToken");
            }


            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("access_token", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(accessToken)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.RevokeChannelToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/v2/oauth/revoke", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RevokeChannelToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Revoke channel access token v2.1
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Channel ID</param>
        /// <param name="clientSecret">Channel Secret</param>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void RevokeChannelTokenByJWT(string clientId, string clientSecret, string accessToken, int operationIndex = 0)
        {
            RevokeChannelTokenByJWTWithHttpInfo(clientId, clientSecret, accessToken);
        }

        /// <summary>
        ///  Revoke channel access token v2.1
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Channel ID</param>
        /// <param name="clientSecret">Channel Secret</param>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Linebotsdkx.ChannelAccessToken.Client.ApiResponse<Object> RevokeChannelTokenByJWTWithHttpInfo(string clientId, string clientSecret, string accessToken, int operationIndex = 0)
        {
            // verify the required parameter 'clientId' is set
            if (clientId == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientId' when calling ChannelAccessTokenApi->RevokeChannelTokenByJWT");
            }

            // verify the required parameter 'clientSecret' is set
            if (clientSecret == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientSecret' when calling ChannelAccessTokenApi->RevokeChannelTokenByJWT");
            }

            // verify the required parameter 'accessToken' is set
            if (accessToken == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'accessToken' when calling ChannelAccessTokenApi->RevokeChannelTokenByJWT");
            }

            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("client_id", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientId)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_secret", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientSecret)); // form parameter
            localVarRequestOptions.FormParameters.Add("access_token", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(accessToken)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.RevokeChannelTokenByJWT";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/oauth2/v2.1/revoke", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RevokeChannelTokenByJWT", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Revoke channel access token v2.1
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Channel ID</param>
        /// <param name="clientSecret">Channel Secret</param>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RevokeChannelTokenByJWTAsync(string clientId, string clientSecret, string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await RevokeChannelTokenByJWTWithHttpInfoAsync(clientId, clientSecret, accessToken, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        ///  Revoke channel access token v2.1
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="clientId">Channel ID</param>
        /// <param name="clientSecret">Channel Secret</param>
        /// <param name="accessToken">Channel access token</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Linebotsdkx.ChannelAccessToken.Client.ApiResponse<Object>> RevokeChannelTokenByJWTWithHttpInfoAsync(string clientId, string clientSecret, string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'clientId' is set
            if (clientId == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientId' when calling ChannelAccessTokenApi->RevokeChannelTokenByJWT");
            }

            // verify the required parameter 'clientSecret' is set
            if (clientSecret == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'clientSecret' when calling ChannelAccessTokenApi->RevokeChannelTokenByJWT");
            }

            // verify the required parameter 'accessToken' is set
            if (accessToken == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'accessToken' when calling ChannelAccessTokenApi->RevokeChannelTokenByJWT");
            }


            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("client_id", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientId)); // form parameter
            localVarRequestOptions.FormParameters.Add("client_secret", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(clientSecret)); // form parameter
            localVarRequestOptions.FormParameters.Add("access_token", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(accessToken)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.RevokeChannelTokenByJWT";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/oauth2/v2.1/revoke", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("RevokeChannelTokenByJWT", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Verify the validity of short-lived and long-lived channel access tokens
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">A short-lived or long-lived channel access token.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>VerifyChannelAccessTokenResponse</returns>
        public VerifyChannelAccessTokenResponse VerifyChannelToken(string accessToken, int operationIndex = 0)
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<VerifyChannelAccessTokenResponse> localVarResponse = VerifyChannelTokenWithHttpInfo(accessToken);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Verify the validity of short-lived and long-lived channel access tokens
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">A short-lived or long-lived channel access token.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of VerifyChannelAccessTokenResponse</returns>
        public Linebotsdkx.ChannelAccessToken.Client.ApiResponse<VerifyChannelAccessTokenResponse> VerifyChannelTokenWithHttpInfo(string accessToken, int operationIndex = 0)
        {
            // verify the required parameter 'accessToken' is set
            if (accessToken == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'accessToken' when calling ChannelAccessTokenApi->VerifyChannelToken");
            }

            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("access_token", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(accessToken)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.VerifyChannelToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<VerifyChannelAccessTokenResponse>("/v2/oauth/verify", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("VerifyChannelToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Verify the validity of short-lived and long-lived channel access tokens
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">A short-lived or long-lived channel access token.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VerifyChannelAccessTokenResponse</returns>
        public async System.Threading.Tasks.Task<VerifyChannelAccessTokenResponse> VerifyChannelTokenAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<VerifyChannelAccessTokenResponse> localVarResponse = await VerifyChannelTokenWithHttpInfoAsync(accessToken, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Verify the validity of short-lived and long-lived channel access tokens
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">A short-lived or long-lived channel access token.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VerifyChannelAccessTokenResponse)</returns>
        public async System.Threading.Tasks.Task<Linebotsdkx.ChannelAccessToken.Client.ApiResponse<VerifyChannelAccessTokenResponse>> VerifyChannelTokenWithHttpInfoAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'accessToken' is set
            if (accessToken == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'accessToken' when calling ChannelAccessTokenApi->VerifyChannelToken");
            }


            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/x-www-form-urlencoded"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.FormParameters.Add("access_token", Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToString(accessToken)); // form parameter

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.VerifyChannelToken";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<VerifyChannelAccessTokenResponse>("/v2/oauth/verify", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("VerifyChannelToken", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token with a user-specified expiration (Channel Access Token v2.1).</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>VerifyChannelAccessTokenResponse</returns>
        public VerifyChannelAccessTokenResponse VerifyChannelTokenByJWT(string accessToken, int operationIndex = 0)
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<VerifyChannelAccessTokenResponse> localVarResponse = VerifyChannelTokenByJWTWithHttpInfo(accessToken);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token with a user-specified expiration (Channel Access Token v2.1).</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of VerifyChannelAccessTokenResponse</returns>
        public Linebotsdkx.ChannelAccessToken.Client.ApiResponse<VerifyChannelAccessTokenResponse> VerifyChannelTokenByJWTWithHttpInfo(string accessToken, int operationIndex = 0)
        {
            // verify the required parameter 'accessToken' is set
            if (accessToken == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'accessToken' when calling ChannelAccessTokenApi->VerifyChannelTokenByJWT");
            }

            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToMultiMap("", "access_token", accessToken));

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.VerifyChannelTokenByJWT";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<VerifyChannelAccessTokenResponse>("/oauth2/v2.1/verify", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("VerifyChannelTokenByJWT", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token with a user-specified expiration (Channel Access Token v2.1).</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of VerifyChannelAccessTokenResponse</returns>
        public async System.Threading.Tasks.Task<VerifyChannelAccessTokenResponse> VerifyChannelTokenByJWTAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Linebotsdkx.ChannelAccessToken.Client.ApiResponse<VerifyChannelAccessTokenResponse> localVarResponse = await VerifyChannelTokenByJWTWithHttpInfoAsync(accessToken, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
        /// </summary>
        /// <exception cref="Linebotsdkx.ChannelAccessToken.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accessToken">Channel access token with a user-specified expiration (Channel Access Token v2.1).</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (VerifyChannelAccessTokenResponse)</returns>
        public async System.Threading.Tasks.Task<Linebotsdkx.ChannelAccessToken.Client.ApiResponse<VerifyChannelAccessTokenResponse>> VerifyChannelTokenByJWTWithHttpInfoAsync(string accessToken, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'accessToken' is set
            if (accessToken == null)
            {
                throw new Linebotsdkx.ChannelAccessToken.Client.ApiException(400, "Missing required parameter 'accessToken' when calling ChannelAccessTokenApi->VerifyChannelTokenByJWT");
            }


            Linebotsdkx.ChannelAccessToken.Client.RequestOptions localVarRequestOptions = new Linebotsdkx.ChannelAccessToken.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Linebotsdkx.ChannelAccessToken.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(Linebotsdkx.ChannelAccessToken.Client.ClientUtils.ParameterToMultiMap("", "access_token", accessToken));

            localVarRequestOptions.Operation = "ChannelAccessTokenApi.VerifyChannelTokenByJWT";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<VerifyChannelAccessTokenResponse>("/oauth2/v2.1/verify", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("VerifyChannelTokenByJWT", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
